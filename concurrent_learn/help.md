# C++ 11 线程库的基本使用
## 创建线程
```cpp
#include <thread>
std::thread t(function_name, args...);
```
创建线程后，我们可以使用 t.join() 等待线程完成，或者使用 t.detach() 分离线程，让它在后台运行。
## 传递参数
不能传递**临时变量**，因为线程可能在变量销毁后才访问它。可以使用**引用**或**智能指针**来传递参数。

使用std::ref传递引用：
## join方法与joinable接口
join() 方法会阻塞当前线程，直到被调用的线程完成执行。

有些线程不能直接调用join()。
1. 一种情况是分离线程（detached thread）。如果尝试对分离线程调用join()，会导致程序异常终止。
2. 一种情况是线程已经被join过，再次调用join()会抛出异常。
3. 一种情况是线程对象没有关联任何线程（默认构造的线程对象），调用join()也会抛出异常。
4. 一种情况是线程已经结束执行，再次调用join()会抛出异常。

在调用join()之前，可以使用joinable()方法检查线程是否可以被join：

## detach方法
detach() 方法将线程与其线程对象分离，使线程在后台运行，独立于主线程。
主要的应用场景包括：
1. **后台任务**：适用于需要在后台运行且不需要与主线程同步的任务。
2. **事件监听**：适用于需要持续监听某些事件（如网络连接、用户输入等）的任务。
3. **定时任务**：适用于需要定期执行某些操作的任务，如定时备份、定时清理等。
4. **资源管理**：适用于需要独立管理资源的任务，如文件读写、数据库操作等。

如果主线程结束，所有分离的线程也会被强制终止，因此需要确保分离线程在主线程结束前完成其任务。

# 线程中的数据未定义错误
1. 传递临时变量
	**解决方案**：使用引用或智能指针传递参数，确保变量在子线程访问时仍然有效。
2. 传递指针或引用时，主线程提前销毁了对象
	**解决方案**：确保对象在子线程访问期间保持有效，或者使用智能指针管理对象的生命周期。

# 使用互斥量保护共享数据
	多线程访问共享数据时，可能会导致数据竞争和未定义行为。使用互斥量（mutex）可以保护共享数据，确保同一时间只有一个线程访问它。
> mtx.lock()获取互斥量的所有权，保证当前线程独占访问shared_data。  
> mtx.unlock()释放互斥量，使其他线程可以继续访问shared_data。

# 互斥量死锁问题
死锁出现的场景：
1. 递归锁：线程在持有锁的情况下再次尝试获取同一把锁，导致死锁。
1. 多锁获取顺序不一致：多个线程以不同的顺序获取多个锁，可能导致循环等待，从而引发死锁。

死锁通常发生在以下几种情况：
1. **互斥条件**：至少有一个资源必须处于非共享模式，即某个资源在同一时间只能被一个线程占用。
1. **持有并等待条件**：一个线程至少持有一个资源，并等待获取其他线程持有的资源。
1. **不剥夺条件**：资源不能被强制剥夺，必须由持有资源的线程自行释放。
1. **循环等待条件**：存在一个线程循环等待的链条，每个线程都在等待下一个线程持有的资源。

解决方法：
1. 按顺序获取锁：确保所有线程以相同的顺序获取多个锁，避免循环等待。
1. 使用try_lock：尝试获取锁，如果获取失败则释放已持有的锁，避免死锁。

# 线程池
线程池是一种管理多个线程的机制，可以重用线程来执行多个任务，**避免频繁创建和销毁线程带来的开销**。使用线程池可以提高程序的性能和响应速度。

实现思路：
1. 构造和析构
1. 创建任务队列
1. 单例模式